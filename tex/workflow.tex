\section{Workflow}

% Describe workflow here
The workflow of the project defines how the group members will work together to achieve the intended end result.
This includes how one approaches the development of the project such as software development methodologies and what set of tools to use throughout the project.

\subsection{Meetings and work sessions} 
All the group members have agreed to meet twice a week to mainly discuss the status of the project, distributing workload and to discuss further improvements or goals.
The internal meetings occur weekly every Monday and Thursday lunch from 12.10 to 13.00.
Also, on Tuesdays the group has reoccurring meetings with the project's supervisor for feedback, ideas, and to help guide the project in the right direction.
All group members are expected to attend all meetings and therefore follow an opt-out regimen.

Additionally, on Thursday afternoon and throughout Friday the group has decided to meet for common work sessions on a weekly basis.
The intended reason for these sessions is for the group to sit down together and help each other solve problems that often require communication between the different implementations.
Furthermore, the sessions make each member more approachable and keep group members updated on the overall status of the project.
These are not mandatory but still enforces an opt-out regimen to encourage more collaboration.

\subsection{Git and GitHub}
Git was chosen as it is the industry standard for version control of code \cite{git_industry_standard}.
For collaboration purposes, the git repository will be hosted on GitHub.
Most project members had previous experience with both of these tools, and that ended up becoming the deciding factor to use these tools as opposed to similar ones such as Subversion and GitLab.

\subsection{Unity and C\#}
The project requires a GUI for the visualization of cities, so some type of library, framework, or engine was needed to alleviate some of this work.
LWJGL \cite{lwjgl}, JMonkeyEngine \cite{jmonkey}, Unity \cite{unity}, Unreal Engine \cite{unreal}, and Godot \cite{godot} were all options that were considered in this project.
Unreal Engine was excluded because of its hard learning curve, and the way it favors visual programming using something called \textit{blueprints}.
Godot was excluded for its limitations in 3D and its young and small community.
LWJGL and JMonkeyEngine were disregarded for the amount of work that would have been required to get simple stuff like roads and visual debugging to work.
The choice ended up being Unity as it will allow focus to be put on the PCG of the problem as opposed to developing our own framework.
Further arguments for using Unity were its large community, extensive range of tutorials, good documentation, stability, cross-platform support, and its wide array of first-, and third-party tools.

Unity officially only supports C\#, and since this language is similar to Java (a language all project members had previous experience with) the choice of programming language felt obvious.